#!/bin/bash

# exit script if return code != 0
set -e

# redirect new file descriptors and then tee stdout & stderr to supervisor log and console (captures output from this script)
exec 3>&1 4>&2 &> >(tee -a /config/supervisord.log)

# source in utilities script
source 'utils.sh'

cat << "EOF"
Created by...
___.   .__       .__
\_ |__ |__| ____ |  |__   ____ ___  ___
 | __ \|  |/    \|  |  \_/ __ \\  \/  /
 | \_\ \  |   |  \   Y  \  ___/ >    <
 |___  /__|___|  /___|  /\___  >__/\_ \
     \/        \/     \/     \/      \/
   https://hub.docker.com/u/binhex/

EOF

# source in environment variables containing information about the build
# this file is generated by the build script and contains the app name and release tag
source '/etc/image-build-info'

if [[ "${HOST_OS,,}" == "unraid" ]]; then
	echo "[info] Host is running unRAID" | ts '%Y-%m-%d %H:%M:%.S'
fi

echo "[info] System information: $(uname -a)" | ts '%Y-%m-%d %H:%M:%.S'

echo "[info] Image architecture: '${TARGETARCH}'" | ts '%Y-%m-%d %H:%M:%.S'

echo "[info] Application name: '${APPNAME}'" | ts '%Y-%m-%d %H:%M:%.S'

echo "[info] Base image release tag: '${BASE_RELEASE_TAG}'" | ts '%Y-%m-%d %H:%M:%.S'

echo "[info] Application image release tag: '${IMAGE_RELEASE_TAG}'" | ts '%Y-%m-%d %H:%M:%.S'

# NOTE Do not move PUID/PGID below PLACEHOLDERS, as they are referenced
export PUID=$(echo "${PUID}" | sed -e 's~^[ \t]*~~;s~[ \t]*$~~')
if [[ ! -z "${PUID}" ]]; then
	echo "[info] PUID defined as '${PUID}'" | ts '%Y-%m-%d %H:%M:%.S'
else
	echo "[warn] PUID not defined (via -e PUID), defaulting to '99'" | ts '%Y-%m-%d %H:%M:%.S'
	export PUID="99"
fi

# set nsswitch.conf to only use files for user/group resolution
# fix for issues with usermod/groupmod taking a long time to process
sed -i 's/^passwd:.*/passwd: files/' /etc/nsswitch.conf
sed -i 's/^group:.*/group: files/' /etc/nsswitch.conf

# set user nobody to specified user id (non unique)
current_uid=$(id -u nobody)
if [[ "${current_uid}" != "${PUID}" ]]; then
	echo "[info] Executing usermod for PUID '${PUID}'..." | ts '%Y-%m-%d %H:%M:%.S'
	usermod -o -u "${PUID}" nobody &>/dev/null
	echo "[info] usermod completed successfully" | ts '%Y-%m-%d %H:%M:%.S'
else
	echo "[info] User 'nobody' already has UID '${PUID}', skipping usermod" | ts '%Y-%m-%d %H:%M:%.S'
fi

export PGID=$(echo "${PGID}" | sed -e 's~^[ \t]*~~;s~[ \t]*$~~')
if [[ ! -z "${PGID}" ]]; then
	echo "[info] PGID defined as '${PGID}'" | ts '%Y-%m-%d %H:%M:%.S'
else
	echo "[warn] PGID not defined (via -e PGID), defaulting to '100'" | ts '%Y-%m-%d %H:%M:%.S'
	export PGID="100"
fi

# set group users to specified group id (non unique)
current_gid=$(getent group users | cut -d: -f3)
if [[ "${current_gid}" != "${PGID}" ]]; then
	echo "[info] Executing groupmod for PGID '${PGID}'..." | ts '%Y-%m-%d %H:%M:%.S'
	groupmod -o -g "${PGID}" users &>/dev/null
	echo "[info] groupmod completed successfully" | ts '%Y-%m-%d %H:%M:%.S'
else
	echo "[info] Group 'users' already has GID '${PGID}', skipping groupmod" | ts '%Y-%m-%d %H:%M:%.S'
fi

# set umask to specified value if defined
if [[ ! -z "${UMASK}" ]]; then
	echo "[info] UMASK defined as '${UMASK}'" | ts '%Y-%m-%d %H:%M:%.S'
	sed -i -e "s~umask.*~umask = ${UMASK}~g" /etc/supervisor/conf.d/*.conf
else
	echo "[warn] UMASK not defined (via -e UMASK), defaulting to '000'" | ts '%Y-%m-%d %H:%M:%.S'
	sed -i -e "s~umask.*~umask = 000~g" /etc/supervisor/conf.d/*.conf
fi

# check for presence of perms file, if it exists then skip setting
# permissions, otherwise recursively set on /config for host
if [[ ! -f "/config/perms.txt" ]]; then

	if [[ -d "/config" ]]; then

		echo "[info] Setting ownership and permissions recursively on '/config'..." | ts '%Y-%m-%d %H:%M:%.S'

		set +e
		chown -R "${PUID}":"${PGID}" "/config"
		exit_code_chown=$?
		chmod -R 775 "/config"
		exit_code_chmod=$?
		set -e

		if (( exit_code_chown != 0 || exit_code_chmod != 0 )); then
			echo "[warn] Unable to chown/chmod '/config', assuming SMB mountpoint" | ts '%Y-%m-%d %H:%M:%.S'
		else
			echo "[info] Successfully set ownership and permissions on '/config'" | ts '%Y-%m-%d %H:%M:%.S'
		fi

	else

		echo "[fatal] '/config' directory does not exist, exiting script..." | ts '%Y-%m-%d %H:%M:%.S'
		exit 1

	fi

	if [[ -d "/data" ]]; then

		echo "[info] Setting ownership and permissions non-recursively on '/data'..." | ts '%Y-%m-%d %H:%M:%.S'

		set +e
		chown "${PUID}":"${PGID}" "/data"
		exit_code_chown=$?
		chmod 775 "/data"
		exit_code_chmod=$?
		set -e

		if (( exit_code_chown != 0 || exit_code_chmod != 0 )); then
			echo "[info] Unable to chown/chmod '/data', assuming SMB mountpoint" | ts '%Y-%m-%d %H:%M:%.S'
		else
			echo "[info] Successfully set ownership and permissions on '/data'" | ts '%Y-%m-%d %H:%M:%.S'
		fi

	else

		echo "[info] '/data' directory does not exist, skipping setting (non-recursive) ownership and permissions on '/data'" | ts '%Y-%m-%d %H:%M:%.S'

	fi

	echo "This file prevents ownership and permissions from being applied/re-applied to '/config' and '/data', if you want to reset ownership and permissions then please delete this file and restart the container." > /config/perms.txt

else

	echo "[info] Permissions file '/config/perms.txt' exists, skipping setting ownership and permissions on '/config' and '/data'" | ts '%Y-%m-%d %H:%M:%.S'

fi

# calculate disk usage for /tmp in bytes
disk_usage_tmp=$(du -s /tmp | awk '{print $1}')

# if disk usage of /tmp exceeds 1GB then do not clear down
# (could possibly be volume mount to media)
if [ "${disk_usage_tmp}" -gt 1073741824 ]; then

	echo "[warn] /tmp directory contains 1GB+ of data, skipping clear down as this maybe mounted media" | ts '%Y-%m-%d %H:%M:%.S'
	echo "[info] Showing contents of /tmp..." | ts '%Y-%m-%d %H:%M:%.S'
	ls -al /tmp

else

	echo "[info] Deleting files in /tmp (non recursive)..." | ts '%Y-%m-%d %H:%M:%.S'
	rm -f /tmp/* > /dev/null 2>&1 || true
	rm -rf /tmp/tmux*

fi

# ENVVARS_COMMON_PLACEHOLDER

# ENVVARS_PLACEHOLDER

# PERMISSIONS_PLACEHOLDER

echo "[info] Applying chown to paths '${install_paths}'..." | ts '%Y-%m-%d %H:%M:%.S'

# get previous puid/pgid (if first run then will be empty string)
previous_puid=$(cat "/root/puid" 2>/dev/null || true)
previous_pgid=$(cat "/root/pgid" 2>/dev/null || true)

# if first run (no puid or pgid files in /tmp) or the PUID or PGID
# env vars are different from the previous run then re-apply chown
# with current PUID and PGID values.
if [[ ! -f "/root/puid" || ! -f "/root/pgid" || "${previous_puid}" != "${PUID}" || "${previous_pgid}" != "${PGID}" ]]; then

	# loop over the list of paths and run chown in parallel to sped up
	# the process for people running overlay2
	for path in ${install_paths}; do
		if [[ -d "${path}" ]]; then
			# 32 parallel processes, batch size of 100 files
			find "${path}" -print0 | \
				xargs -0 -n 100 -P 32 chown "${PUID}":"${PGID}" &
		fi
	done
	wait

fi

# write out current PUID and PGID to files in /root (used to compare
# on next run)
echo "${PUID}" > /root/puid
echo "${PGID}" > /root/pgid

# set permissions to allow rw for all users (used when appending util
# output to supervisor log)
chmod 666 "/config/supervisord.log"

# CONFIG_PLACEHOLDER

echo "[info] Starting Supervisor..." | ts '%Y-%m-%d %H:%M:%.S'

# restore file descriptors to prevent duplicate stdout & stderr to
# supervisord.log
exec 1>&3 2>&4

exec /usr/bin/supervisord -c /etc/supervisord.conf -n
